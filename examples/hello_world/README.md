# Hello World, Async

This is example code of writing an Nginx module in Rust
and making use of Rust's Async capabilities.

## Getting Started

This code has been tested on Linux. It will likely work on OSX. Windows? Who knows.

To get started, clone the [Nginx Source Code](https://github.com/nginx/nginx):
`git clone https://github.com/nginx/nginx.git`.

Then set up Nginx for the release you want to build against:

```bash
cd nginx
export NGINX_DIR=$(pwd)
git checkout release-1.19.10 # or whatever release you want to use
```

Next, check out this code:

```bash
cd ~/stuff # or where-ever you check stuff out on your machine
git clone https://github.com/dpp/nginx-rs.git
cd nginx-rs/examples/hello-world
./setup.sh # configures Nginx
./smoke_test.sh
```

Point your browser to [https://localhost:8000](http://localhost:8000)
and you'll see a message generated by Rust code running async and not
blocking the Nginx worker thread.


## Basics

Much of the basics of Nginx module development can be found
in [Emiller's Guide](https://www.evanmiller.org/nginx-modules-guide.html).
The core parts of the code is pretty much a C to Rust transliteration.

However, there are some Rust-isms in the Hello World example.

### Rust Context

The handlers get a `Request` object which is a wrapper around the
Nginx `ngx_http_request_t` pointer, but with some helpers. The
most notable helper is the `get_or_init_context` method.

This method allows you to store custom Rust `struct`s in
your module's Nginx context and the structs are properly
released when the request processing cycle is over.

For example:

```
let (info, _) = request.get_or_init_context(|| HelloContext::new());
```

The above code gets the context object if it already exists and if it doesn't
one will be created and inserted into the request context.

In the above code snippet, `info` has the type `Arc<HelloContext>`.

The context variables are immutable, but the
[interior mutability](https://doc.rust-lang.org/reference/interior-mutability.html)
pattern can be used to safely share state across threads.

### Async

Nginx is single threaded. Nginx is event driven. When an event (e.g. network data)
happens, Nginx chooses an event handler which handles the event. Each
event handler should be "fast" and not block with I/O or other 
actions.

This makes writing Nginx modules that need to go "off process" a real challenge.
While Nginx was pure magic as C code back in the early 2000s, we've seen significant
advances in asynchronous programming since then. Go has build-in and invisible-to-the-coder
support for asynchronous coding. JavaScript and Rust both have async support, but it's
visible to the coder.

[Rust's Async](https://rust-lang.github.io/async-book/) is a syntactically nice
way to release operating system threads during I/O and other blocking operations.
[Tokio](https://tokio.rs/) provides an excellent implementation of Async in Rust.

### When world should collide

Being able to use Rust for business logic and for communicating with external systems
and processes is a whole ton easier than doing the equivalent in Rust than in C
with Nginx's limitations of not blocking the worker thread.

The approach is simple: use the context object with interior mutability to communicate
between the worker thread and async code running on Tokio threads.

The example code runs in the access phase. It gets context and if the "count" is
less than 20, run some code in async-land:

```rust
        let (info, _) = request.get_or_init_context(|| HelloContext::new());
        let v = info.get_count();

        // if we've run the external stuff for this request less than 20 times,
        // send a function to Async/Tokio land for processing
        if v < 20 {
```

To run the code in Async-land: `return request.run_in_background(`

The `run_in_background` function increments the `ngx_http_request_t`'s `blocked` counter and
returns `NGX_AGAIN`. Additionally, the function takes the code returned by the `build_worker!`
macro and sends the code to Async-land for execution:

```rust
                // the `build_worker` macro takes the variable name of the
                // `Request` struct and a block of async code and constructs
                // all the information needed to hand stuff off to Async-land
                // once the block is completed, the Async handler signals
                // the Nginx worker thread to re-run the request and the
                // function is called again.
                //
                // The only way to communicate between the Nginx worker thread
                // (which should not be blocked) and Async-land is via the context
                // object. The Context object should be a struct that supports inner
                // mutability. In this example, both Atomics and Mutexs are
                // used to support thread-safe inner mutability
                build_worker!(request, {
                    // get the context information
                    if let Some(q2) = request.get_context::<HelloContext>() {
                        // if the count is 1, do an HTTP request
                        if q2.get_count() == 1 {
                            q2.fetch_info().await;
                        }
                        // increment the count
                        q2.inc_count();

                        // we're recomputing the access each time through the loop... not
                        // necessary, but why not?
                        q2.set_allow(!request.user_agent().as_bytes().starts_with(b"curl"));
                    }

                    // a nice async sleep
                    sleep(Duration::from_millis(22)).await;
                })
```

The code demonstrates an async HTTP request:

```rust
    pub async fn fetch_info(&self) {
        // an example of making an HTTP request in the Async thread. This
        // could be a REST call, a gRPC call, or anything else that can be
        // done with Rust Async
        let resp: reqwest::Response = get("https://httpbin.org/ip").await.unwrap();
        let s = format!("{}", resp.text().await.unwrap());
        self.set_fetched(Some(s));
    }
```

As well as a simple 22 millisecond sleep (repeated for each of the 20 iterations of
async code execution per request).

## What's Next?

The example shows the basics of building complex business logic in Rust
that accesses external services without blocking the Nginx worker thread
and with code that's readable and maintainable.

There are likely macros and other stuff that can make the definition of Nginx
"rituals" go from high boilerplate to mid-to-low boilerplate.





